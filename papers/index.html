<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Papers — A. Laface</title>
  <link rel="stylesheet" href="../assets/css/style.css">
</head>
<body>
<header>
  <nav>
    <a class="brand" href="../">Antonio&nbsp;Laface</a>
    <a href="./">Papers</a>
    <a href="../arxiv/">arXiv</a>
    <a href="../software/">Software</a>
    <a href="../notes/">Lecture notes</a>
    <a href="../book/">Book</a>
  </nav>
</header>

<main>
  <h1>Published papers</h1>
  <p>This page tries zbMATH Open first; if unavailable or no exact matches, it falls back to Crossref (filtered via ORCID).</p>

  <div id="source-badge" class="card" style="padding:.5rem 1rem; display:none;"></div>
  <div id="papers" class="card"><p>Loading…</p></div>

  <p style="font-size:.95em;color:#57606a;margin-top:1rem">
    Data sources: zbMATH Open (preferred), Crossref (fallback). MR links added when a DOI is available.
  </p>
</main>

<footer>© <span id="y"></span> Antonio Laface</footer>
<script>document.getElementById('y').textContent = new Date().getFullYear();</script>

<script>
// ------- Config -------
const ZB_AUTHOR = 'Laface, Antonio';
const ORCID = '0000-0001-6926-8249';
const SIZE = 200;
const ZB_URL = `https://api.zbmath.org/v1/document?q=${encodeURIComponent('au:"'+ZB_AUTHOR+'"')}&size=${SIZE}&sort=year.desc`;
const CROSSREF_URL = `https://api.crossref.org/works?filter=orcid:${encodeURIComponent(ORCID)}&rows=${SIZE}&sort=issued&order=desc&select=title,author,DOI,URL,issued,container-title,volume,issue,page`;

// ------- Helpers -------
const $ = id => document.getElementById(id);
const esc = s => (s||"").toString().replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));
const yearOf = it => it.year || it?.issued?.['date-parts']?.[0]?.[0] || '';
const doiURL = doi => doi ? `https://doi.org/${encodeURIComponent(doi)}` : '';
const mrLookup = doi => doi ? `https://mathscinet.ams.org/mathscinet/relay?mr=Lookup&url=https://mathscinet.ams.org/mathscinet/search/publications.html?pg1=DOI&s1=${encodeURIComponent(doi)}` : '';
const zbDocURL = id => id ? `https://zbmath.org/?q=an:${encodeURIComponent(id)}` : '';

function showSource(text){
  const el = $('source-badge');
  el.textContent = text;
  el.style.display = 'block';
}

function render(items){
  if (!items?.length) { $('papers').innerHTML = '<p>No records found.</p>'; return; }
  const html = items.map(it => {
    const title = it.title || it.ti || (Array.isArray(it.title)?.[0]) || (Array.isArray(it.titleArr)?.[0]) || "(untitled)";
    const yr = yearOf(it);

    // authors (support both schemas)
    let authors = "";
    if (it._source === 'zb') {
      const list = it.authors || it.author || it.au || [];
      authors = list.map(a => typeof a === 'string' ? a : (a.name || [a.first, a.last].filter(Boolean).join(' '))).join(', ');
    } else {
      const list = it.author || [];
      authors = list.map(a => [a.given, a.family].filter(Boolean).join(' ')).join(', ');
    }

    const journal = it.journal || it.journal_title || it?.containerTitle || (it['container-title']?.[0]) || '';
    const vol = it.volume || it.vol || '';
    const issue = it.issue || it.no || it['journal-issue']?.issue || '';
    const page = it.pages || it.page || '';
    const citeTail = [vol && ` ${esc(vol)}`, issue && `(${esc(issue)})`, page && `:${esc(page)}`].filter(Boolean).join('');

    const doi = it.doi || (Array.isArray(it.dois)?it.dois[0]:it.DOI) || '';
    const url = it.url || it.link || it.URL || doiURL(doi) || zbDocURL(it.id || it.an);

    return `
      <div class="card">
        <h3 style="margin-top:0"><a href="${esc(url)}" target="_blank" rel="noopener">${esc(title)}</a></h3>
        <p><strong>Authors:</strong> ${esc(authors)}</p>
        <p><strong>Journal:</strong> ${esc(journal)}${citeTail ? esc(citeTail) : ''}${yr ? ` · <strong>Year:</strong> ${esc(String(yr))}` : ''}</p>
        <p>
          ${doi ? `DOI: <a href="${esc(doiURL(doi))}" target="_blank" rel="noopener">${esc(doi)}</a>` : ''}
          ${doi ? ` · <a href="${esc(mrLookup(doi))}" target="_blank" rel="noopener">MR lookup</a>` : ''}
        </p>
      </div>`;
  }).join('');
  $('papers').innerHTML = html;
}

function errorOut(msg, link){
  $('papers').innerHTML = `<p>${esc(msg)}${link ? ' — ' + link : ''}</p>`;
}

// strict author match for zbMATH
function includesExactZbName(list){
  return (list||[]).some(a => {
    const name = typeof a === 'string' ? a : (a.name || [a.first, a.last].filter(Boolean).join(', '));
    const n = (name||'').trim().toLowerCase();
    return n === 'laface, antonio' || n === 'antonio laface';
  });
}

// ------- Timed fetch with fallback -------
(async function load(){
  // race zbMATH vs timeout
  const zbPromise = (async () => {
    const r = await fetch(ZB_URL, { method: 'GET' });
    if (!r.ok) throw new Error('zbMATH HTTP ' + r.status);
    const data = await r.json();
    const raw = data?.data || data?.hits || data?.documents || data?.items || [];
    const filtered = raw.filter(it => includesExactZbName(it.authors || it.author || it.au));
    if (!filtered.length) throw new Error('zbMATH: no exact matches');
    filtered.forEach(it => it._source = 'zb');
    return filtered;
  })();

  const timeout = new Promise((_, rej) => setTimeout(() => rej(new Error('zbMATH timeout')), 4000));

  try {
    const zbItems = await Promise.race([zbPromise, timeout]);
    showSource('Data source: zbMATH Open');
    render(zbItems);
    return;
  } catch (_) {
    // Crossref fallback with ORCID
    try {
      const r = await fetch(CROSSREF_URL);
      if (!r.ok) throw new Error('Crossref HTTP ' + r.status);
      const j = await r.json();
      let items = j?.message?.items || [];
      // keep only entries that list your ORCID or exact name
      items = items.filter(it => {
        const list = it.author || [];
        return list.some(a =>
          (a.ORCID && a.ORCID.replace(/^https?:\/\/orcid\.org\//,'') === ORCID) ||
          ((a.given||'').trim().toLowerCase()==='antonio' && (a.family||'').trim().toLowerCase()==='laface')
        );
      });
      items.forEach(it => it._source = 'crossref');
      showSource('Data source: Crossref (fallback)');
      render(items);
    } catch (e2) {
      errorOut(
        'Both zbMATH and Crossref are unreachable right now.',
        `<a href="https://zbmath.org/authors/?q=au%3A%22${encodeURIComponent(ZB_AUTHOR)}%22" target="_blank" rel="noopener">zbMATH author page</a>`
      );
    }
  }
})();
</script>
</body>
</html>
